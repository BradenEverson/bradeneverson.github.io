<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <title>RHDL - Braden Everson</title>
        <link rel="stylesheet" href="../style.css"/>
    </head>
    <body>
        <a href="../index.html" class="back-link">‚Üê Back to all projects</a>

        <header>
            <h1>RHDL</h1>
            <p class="project-description">VHDL to Minecraft Redstone Circuit Compiler</p>
        </header>

        <div class = "video-wrapper">
            <iframe 
                src="https://www.linkedin.com/embed/feed/update/urn:li:ugcPost:7411092662750990336?compact=1" 
                frameborder="0"
                title="RHDL Video"
                allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" 
                allowfullscreen>
            </iframe>
        </div>
        <p class="video-caption">RHDL Demo</p>

        <section id="motivation">
            <h2>Motivation</h2>
            <div class="section-content">
                <p>I've always been interested in is the Turing Completeness of seemingly simple mechanics within video games. For example, Minecraft's Redstone wiring system can construct the core boolean logic gates and therefore can represent practically any computational system. With this as an inspiration, I set out 2 months ago to create RHDL, a compiler that uses a VHDL hardware description frontend to emit Minecraft Structure Entity files that represent the digital logic circuit being described. These files are serialized under the Named Binary Tag (NBT) file format the game uses, and can be used in any world in vanilla Minecraft. </p>
            </div>
        </section>
        <section id="implementation">
            <h2>Implementation</h2>
            <div class="section-content">
                <h3>Core Concepts</h3>
                <p>Before we get too down and in the weeds with the implementation, there are a few things we should go over. First, VHDL is one of the standard hardware description languages for modern hardware design. It's syntax allows you to define the "black box" of a system as well as the underlying architecture driving that black box through a multitude of different approachs, including logical statements, direct mappings and if statement-style syntax.</p> 

                <p>For example, if we wanted to create a circuit that detects if the input is the number 5 given a 3 bit input, we could write the following VHDL to define the API and architecture:</p>


                <div class="architecture-diagram">
                    <pre>
                    entity FIVE_DETECTOR is
                    port( A0, A1, A2   : in std_logic;
                          Y            : out std_logic);
                    end entity FIVE_DETECTOR;

                    architecture LOGICAL of FIVE_DETECTOR is
                        Y <= A0 and not A1 and A2;
                    end architecture LOGICAL;
                    </pre>
                </div>

                <p>To start, this syntax is what I aim to implement in the RHDL system. There are some more advanced features of VHDL that I would love to have, but I plan to work through after the core system is proven out.</p>

                    
                <h3>Architecture Overview</h3>
                <p>This entire system being designed from scratch required a collection of sub-modules all working together. The goal of translating hardware descriptions directly into a 3D entity in a video game is obviously very involved, and therefore benefits from several intermediate representations that make our jobs easier:</p>

                <div class="architecture-diagram">
                    <pre>
                [VHDL source] => [High Level Entity and Architectures] => [Gate Level Circuit] \\
                                                                                                || 
                                               [NBT Entity] <= [Minecraft Block Description] <=//
                    </pre>
                </div>

                <p>In essence, we need to parse our VHDL, represent the output mappings as a boolean logic circuit, map this circuit into 3D grid space composed up out of the different gates, and finally generate the NBT entity file that Minecraft expects. Simple, right?<p/>

                <h3>1. Parsing VHDL</h3>
                <p>Parsing VHDL was actually a very enjoyable process, as the language is very explicit in the different types of statements that may exist. To start, after tokenizing the input file into keywords and operators we actually care about, parsing is as simple as reading the first word of any top-level description, and following the unique rules for that statement. Both architecture and entity blocks begin by literally saying their name, and end by saying end {their name}! This is mangificent!</p>

                <p>Thanks to this lovely gift from the IEEE 1064 Specification, we can also derive what the first AST we parse this into should look like. Our desired output should be a list of these <code>TopLevel</code> descriptions, being a variant of either <code>entity</code> or <code>architecture</code>. For an entity, we should track the name as well as all inputs and outputs with their specific data type (std_logic is a single bit, std_logic_vector describes a list with a specific set size). Architectures should then track their name and the name of what entity they implement, as well as a list of all mappings from input(s) to output(s) as described by a more traditional AST.</p>

                <p>This makes parsing a very straightforward process, as most of the work we need to do is just asserting certain tokens and keywords are in the proper order before doing some simple recursive descent parsing on the *worst* branches. For instance, for the statement <code>A <= B and not C;</code> we would create a mapping to the AST:</p>

                <div class="architecture-diagram">
                    <pre>
                                                       [AND]
                                                         |
                                                     ---------
                                                    /         \ 
                                                   [B]       [NOT]
                                                               |
                                                              [C]
                    </pre>
                </div>

                <p>If we wanted to evaluate this as some sort of VHDL interpreter, we could simply do a tree-walk. But we don't want to interpret, we want to build a circuit... which can also just be done through a recursive tree-walk :D</p>

                <p>Finally, before we move into the next IR, there is one final pass through of all <code>TopLevel</code>s we must do to make things easier. We will combine all Entities and Architectures that are referring to the same system (same name) so that we have all input/output names and mappings in one nice package for the next subsystem to consume.</p>

                <h3>2. Circuit Intermediate Representation</h3>
                <p>Now that we have a distilled version of the *intent* of the hardware description, we can work our way towards a representation that is easier for us to translate into a 3D Minecraft circuit. As such, all we really need to do on this step is translate our high level Expression ASTs into concrete circuit entities that point to same inputs. I implemented this circuit as a Graph-like structure using a SlotMap as the underlying data structure, meaning we just pass around Graph Indices instead of node pointers (a pattern I learned from the more strict world of Rust that I just like for problems like this now). As such, the <code>Circuit</code> API allows us to request a type of gate to be created, and returns the Gate ID of that created gate. This makes chained graph construction super nice, as can be illustrated in the pseudocode below:</p>

                <div class="architecture-diagram">
                    <pre>
            circuit = new Circuit();

            A = circuit.input("A");
            B = circuit.input("B");

            C = circuit.and(A, B);

            not_C = circuit.not(C);

            output = circuit.output(not_C);
                    </pre>
                </div>

                <p>I mean that just feels great the write out, and luckily for us our AST walker agrees. Translating from high level expression into a circuit is as simple as walking the expr tree recursively depending on the expression type:</p>

                <ul>
                    <li>If we're a binary expr, first eval both left and right, get their Gate IDs and then create a new gate with those IDs as operands</li>
                    <li>If we're unary, do the same but with only the single child expr</li>
                    <li>If we're an input, just return the ID of the input that was already added during the Entity definition</li>
                </ul>

                <p>And just like that, we have created a circuit graph! This is great because it both combines all the expressions from our parsing step into a single circuit that can be used later, and it also is a great area for translating from some higher level VHDL statements into their digital logic equivalents, allowing us to implement some more complex features without needing to change any of the later steps.</p>

                <h3>3. Mapping to a 3D Grid Circuit</h3>
                <p>Oh boy, this section's going to be a lot. Coming in to this subsystem, we have a flat circuit graph representation of the desired logical behavior that our original VHDL was describing. Coming out of this system, we need a 3D functional representation of this system using Minecraft blocks. We have to take into account all of the problems that come with building something real, including signal strength, positioning of gates, input to output pathfinding, collision mitigation, gate resizing based on child sizes, and so much more.</p>

                <h4>3.1. The Basics</h4>
                <p>Before we get too overwhelmed let's just start with what we need: a 3D graph that can have Minecraft blocks 'placed' within it. As such, we will describe a new struct <code>CircuitEntity</code> as a collection of blocks with points. The positional data about a block will be stored through a Point -> Block HashMap, and blocks will be defined as a tagged union with additional metadata based on what the block needs. We will also store inputs and outputs as lists of Points, which will be useful for combining circuits by strining outputs of one to inputs of another. Finally, we'll also store the total size of the circuit by always tracking the most extreme points that may push past the previous size boundaries.</p>

                <h4>3.2. The Gates</h4>
                <p>Our circuit will always be composed out of smaller basic gates: AND, OR, NOT and XOR. As such, these gates can be almost hardcoded as convenience functions that let us very easily create one when need be. As such, we will create methods that return a new <code>CircuitEntity</code> object for each of them. One important design choice we'll make for later is to allow for a "padding" argument in these gate constructors, this will greatly help us later.</p>

                <p>As touched on earlier, Minecraft is Turing complete in that each of these gates can have their truth tables represented by some configuration of Redstone wire and the many components Minecraft lets you have access to. These components are as follows:</p>

                <ul>
                    <li>Repeaters: they take in a Redstone signal from one end and repeat it with the highest strength at the output. There is a configurable delay you can add between the propagation of input to output, with the lowest delay being a single tick of Redstone activity. This component is very important for our giant circuits because a redstone signal dies over the span of 15 or so blocks. Placing repeaters will allow this signal to go further at the cost of an increasted propagation delay.</li>

                    <li>Comparators: A comparator... I am less confident in my explanation. They have 3 inputs: the back and both sides and send an output based on the mode they are in. There are two modes: subtraction and comparison. Subtraction outputs a 1 if the back input is greater than the max of either side's input. Comparision mode will output the back input if it is greater than or equal to both side inputs.</li>

                    <li>Redstone Torch: A power source!</li>

                </ul>

                <p>From these components, we can generate any gate as a construction of them.</p>

                <p>Redstone Wire: *</p>
                <p>Redstone Torch: !</p>
                <p>Repeater: #</p>
                <p>Comparator: %</p>

                <p>OR Gate:</p>
                <div class="architecture-diagram">
                    <pre>
                         *
                     *****
                     #   #
                     *   *
                    </pre>
                </div>

                <p>NOT Gate:</p>
                <div class="architecture-diagram">
                    <pre>
                         *
                        *%
                        #!
                    </pre>
                </div>

                <p>XOR Gate:</p>
                <div class="architecture-diagram">
                    <pre>
                       *
                      **
                    **%%**
                    ******
                    #    #
                    </pre>
                </div>

                <p>AND Gate:</p>
                <div class="architecture-diagram">
                    <pre>
                         *
                    !%#*#%#*#%!   
                     #!  !  !#
                    </pre>
                </div>

                <p>Do I understand exactly how all of these gates work? Not at all. Did I see some diagrams online and play around with them until I had gates you could dynamically pad? Yes!</p>

                <h4>3.3. Combining Gates</h4>
                <p>The next logical step is to take our smaller gates and create some way of connecting and combining them together. This is where tracking inputs and outputs in a <code>CircuitEntity</code> comes in handy! We can create a method that will take two <code>CircuitEntitiy</code>s and wire the output of one to the input of another, modifying the second circuit. By doing this, all we have to do is shift the second circuit entirely over until the input matches the same X coordinate as the output of the other circuit, and then shift the circuit up along the Z axis until no collisions occur. After this, we can do some simple pathfinding to run a redstone wire between the points.</p>

                <p>This works perfectly fine ASSUMING that the parent gate (the one getting it's input wired to) has a large enough padding so that any other gate going to another input of the parent gate would not be caught in some form of collision, which would be no fun. To solve this, we can use the recursive power of our circuit definition to create some dynamic rules for the padding of a gate!</p>

                <ul>
                    <li>For input gates, we only need a padding of 1 block on both sides so nothing overlaps with the wires</li>
                    <li>For Binary gates, we need some specific padding to the gate size plus the largest padding necessary from either child to ensure that child doesn't overlap the other child</li>
                    <li>For unary gates, we simple need the maximum between the gate's size and the size of the child's padding</li>
                </ul>

                <p>This creates a nice little system that allows us to always know how much padding each gate needs before we create it, allowing us to avoid those nasty collisions! This does make the circuit ultimately bigger than an optimal version would be, but regardless I was quite happy with this solution.</p>


                <h3>4. Exporting to NBT</h3>

            </div>
        </section>


        <section id="links">
            <h2>Related Links</h2>
            <div class="links-section">
                <a href="https://github.com/BradenEverson/redstone_description_language">GitHub Repo</a>
                <a href="https://www.linkedin.com/posts/braden-everson_one-thing-ive-always-been-interested-in-activity-7411092737825013760-fqFs?utm_source=share&utm_medium=member_desktop&rcm=ACoAAC2VricB4W-_aOdQGZxX9BNfp-9xeYKLmE0">LinkedIn post</a>
            </div>
        </section>
        <footer></footer>
    </body>
</html>
